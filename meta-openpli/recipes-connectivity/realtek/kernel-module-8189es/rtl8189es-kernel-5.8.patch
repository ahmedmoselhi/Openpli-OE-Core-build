From b9fcd586a4963be63267cd46ceed00aba2e53b7e Mon Sep 17 00:00:00 2001
From: WanWizard <wanwizard@openpli.org>
Date: Tue, 25 Aug 2020 11:57:11 +0100
Subject: patch for kernel 5.8

---
 core/rtw_security.c    | 326 ++++++++++++++++++++---------------------
 include/rtw_security.h |  46 +++---
 2 files changed, 186 insertions(+), 186 deletions(-)

diff --git a/core/rtw_security.c b/core/rtw_security.c
index b4a24fc..f46c13e 100644
--- a/core/rtw_security.c
+++ b/core/rtw_security.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -101,7 +101,7 @@ const char *security_type_str(u8 value)
 #define AES_SW_DEC_CNT_INC(sec, ra)
 #endif /* DBG_SW_SEC_CNT */
 
-//=====WEP related===== 
+//=====WEP related=====
 
 #define CRC32_POLY 0x04c11db7
 
@@ -138,7 +138,7 @@ _func_enter_;
 		if (++keyindex >= key_len)
 			keyindex = 0;
 	}
-_func_exit_;	
+_func_exit_;
 }
 static u32 arcfour_byte(	struct arc4context	*parc4ctx)
 {
@@ -156,21 +156,21 @@ _func_enter_;
 	parc4ctx->y = y;
 	state[y] = (u8)sx;
 	state[x] = (u8)sy;
-_func_exit_;	
+_func_exit_;
 	return state[(sx + sy) & 0xff];
 }
-              
-           
-static void arcfour_encrypt(	struct arc4context	*parc4ctx, 
+
+
+static void arcfour_encrypt(	struct arc4context	*parc4ctx,
 	u8 * dest,
-	u8 * src, 
+	u8 * src,
 	u32 len)
 {
 	u32	i;
-_func_enter_;	
+_func_enter_;
 	for (i = 0; i < len; i++)
 		dest[i] = src[i] ^ (unsigned char)arcfour_byte(parc4ctx);
-_func_exit_;		
+_func_exit_;
 }
 
 static sint bcrc32initialized = 0;
@@ -184,8 +184,8 @@ static u8 crc32_reverseBit( u8 data)
 
 static void crc32_init(void)
 {
-_func_enter_;	
-	if (bcrc32initialized == 1) 
+_func_enter_;
+	if (bcrc32initialized == 1)
 		goto exit;
 	else{
 		sint i, j;
@@ -195,7 +195,7 @@ _func_enter_;
 
 		c = 0x12340000;
 
-		for (i = 0; i < 256; ++i) 
+		for (i = 0; i < 256; ++i)
 		{
 			k = crc32_reverseBit((u8)i);
 			for (c = ((u32)k) << 24, j = 8; j > 0; --j){
@@ -210,24 +210,24 @@ _func_enter_;
 		}
 		bcrc32initialized= 1;
 	}
-exit:	
-_func_exit_;			
+exit:
+_func_exit_;
 }
 
 static u32 getcrc32(u8 *buf, sint len)
 {
 	u8 *p;
 	u32  crc;
-_func_enter_;	
+_func_enter_;
 	if (bcrc32initialized == 0) crc32_init();
 
 	crc = 0xffffffff;       /* preload shift register, per CRC-32 spec */
 
-	for (p = buf; len > 0; ++p, --len) 
+	for (p = buf; len > 0; ++p, --len)
 	{
 		crc = crc32_table[ (crc ^ *p) & 0xff] ^ (crc >> 8);
 	}
-_func_exit_;				
+_func_exit_;
 	return ~crc;    /* transmit complement, per CRC-32 spec */
 }
 
@@ -237,7 +237,7 @@ _func_exit_;
 */
 void rtw_wep_encrypt(_adapter *padapter, u8 *pxmitframe)
 {																	// exclude ICV
-	
+
 	unsigned char	crc[4];
 	struct arc4context	 mycontext;
 
@@ -250,16 +250,16 @@ void rtw_wep_encrypt(_adapter *padapter, u8 *pxmitframe)
 	struct	pkt_attrib	 *pattrib = &((struct xmit_frame*)pxmitframe)->attrib;
 	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
 	struct	xmit_priv		*pxmitpriv=&padapter->xmitpriv;
-	
-_func_enter_;	
 
-	
+_func_enter_;
+
+
 	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
 		return;
 
 #ifdef CONFIG_USB_TX_AGGREGATION
 	hw_hdr_offset = TXDESC_SIZE +
-		 (((struct xmit_frame*)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);	
+		 (((struct xmit_frame*)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);
 #else
 	#ifdef CONFIG_TX_EARLY_MODE
 	hw_hdr_offset = TXDESC_OFFSET+EARLY_MODE_INFO_SIZE;
@@ -269,7 +269,7 @@ _func_enter_;
 #endif
 
 	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + hw_hdr_offset;
-	
+
 	//start to encrypt each fragment
 	if((pattrib->encrypt==_WEP40_)||(pattrib->encrypt==_WEP104_))
 	{
@@ -284,9 +284,9 @@ _func_enter_;
 
 			if((curfragnum+1)==pattrib->nr_frags)
 			{	//the last fragment
-			
+
 				length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
-			
+
 				*((u32 *)crc)=cpu_to_le32(getcrc32(payload,length));
 
 				arcfour_init(&mycontext, wepkey,3+keylength);
@@ -301,23 +301,23 @@ _func_enter_;
 				arcfour_init(&mycontext, wepkey,3+keylength);
 				arcfour_encrypt(&mycontext, payload, payload, length);
 				arcfour_encrypt(&mycontext, payload+length, crc, 4);
-	
+
 			pframe+=pxmitpriv->frag_len;
 			pframe=(u8 *)RND4((SIZE_PTR)(pframe));
 
 			}
-			
-		}		
+
+		}
 
 		WEP_SW_ENC_CNT_INC(psecuritypriv, pattrib->ra);
 	}
-	
-_func_exit_;						
+
+_func_exit_;
 
 }
 
 void rtw_wep_decrypt(_adapter  *padapter, u8 *precvframe)
-{								
+{
 	// exclude ICV
 	u8	crc[4];
 	struct arc4context	 mycontext;
@@ -328,10 +328,10 @@ void rtw_wep_decrypt(_adapter  *padapter, u8 *precvframe)
 	struct	rx_pkt_attrib	 *prxattrib = &(((union recv_frame*)precvframe)->u.hdr.attrib);
 	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
 
-_func_enter_;	
+_func_enter_;
 
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
-	
+
 	//start to decrypt recvframe
 	if((prxattrib->encrypt==_WEP40_)||(prxattrib->encrypt==_WEP104_))
 	{
@@ -345,14 +345,14 @@ _func_enter_;
 		length= ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
 
 		payload=pframe+prxattrib->iv_len+prxattrib->hdrlen;
-		
+
 		//decrypt payload include icv
 		arcfour_init(&mycontext, wepkey,3+keylength);
 		arcfour_encrypt(&mycontext, payload, payload,  length);
-				
+
 		//calculate icv and compare the icv
 		*((u32 *)crc)=le32_to_cpu(getcrc32(payload,length-4));
-		
+
 		if(crc[3]!=payload[length-1] || crc[2]!=payload[length-2] || crc[1]!=payload[length-3] || crc[0]!=payload[length-4])
 		{
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_wep_decrypt:icv error crc[3](%x)!=payload[length-1](%x) || crc[2](%x)!=payload[length-2](%x) || crc[1](%x)!=payload[length-3](%x) || crc[0](%x)!=payload[length-4](%x)\n",
@@ -361,11 +361,11 @@ _func_enter_;
 
 		WEP_SW_DEC_CNT_INC(psecuritypriv, prxattrib->ra);
 	}
-	
-_func_exit_;		
+
+_func_exit_;
 
 	return;
-	
+
 }
 
 //3 		=====TKIP related=====
@@ -375,12 +375,12 @@ static u32 secmicgetuint32( u8 * p )
 {
 	s32 i;
 	u32 res = 0;
-_func_enter_;		
+_func_enter_;
 	for( i=0; i<4; i++ )
 	{
 		res |= ((u32)(*p++)) << (8*i);
 	}
-_func_exit_;		
+_func_exit_;
 	return res;
 }
 
@@ -388,40 +388,40 @@ static void secmicputuint32( u8 * p, u32 val )
 // Convert from Us4Byte32 to Byte[] in a portable way
 {
 	long i;
-_func_enter_;			
+_func_enter_;
 	for( i=0; i<4; i++ )
 	{
 		*p++ = (u8) (val & 0xff);
 		val >>= 8;
 	}
-_func_exit_;		
+_func_exit_;
 }
 
 static void secmicclear(struct mic_data *pmicdata)
 {
 // Reset the state to the empty message.
-_func_enter_;	
+_func_enter_;
 	pmicdata->L = pmicdata->K0;
 	pmicdata->R = pmicdata->K1;
 	pmicdata->nBytesInM = 0;
 	pmicdata->M = 0;
-_func_exit_;	
+_func_exit_;
 }
 
 void rtw_secmicsetkey(struct mic_data *pmicdata, u8 * key )
 {
 	// Set the key
-_func_enter_;		
+_func_enter_;
 	pmicdata->K0 = secmicgetuint32( key );
 	pmicdata->K1 = secmicgetuint32( key + 4 );
 	// and reset the message
 	secmicclear(pmicdata);
-_func_exit_;		
+_func_exit_;
 }
 
 void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b )
 {
-_func_enter_;	
+_func_enter_;
 	// Append the byte to our word-sized buffer
 	pmicdata->M |= ((unsigned long)b) << (8*pmicdata->nBytesInM);
 	pmicdata->nBytesInM++;
@@ -441,24 +441,24 @@ _func_enter_;
 		pmicdata->M = 0;
 		pmicdata->nBytesInM = 0;
 	}
-_func_exit_;			
+_func_exit_;
 }
 
 void rtw_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nbytes )
 {
-_func_enter_;	
+_func_enter_;
 	// This is simple
 	while( nbytes > 0 )
 	{
 		rtw_secmicappendbyte(pmicdata, *src++ );
 		nbytes--;
 	}
-_func_exit_;			
+_func_exit_;
 }
 
 void rtw_secgetmic(struct mic_data *pmicdata, u8 * dst )
 {
-_func_enter_;	
+_func_enter_;
 	// Append the minimum padding
 	rtw_secmicappendbyte(pmicdata, 0x5a );
 	rtw_secmicappendbyte(pmicdata, 0 );
@@ -475,7 +475,7 @@ _func_enter_;
 	secmicputuint32( dst+4, pmicdata->R );
 	// Reset to the empty message.
 	secmicclear(pmicdata);
-_func_exit_;		
+_func_exit_;
 }
 
 
@@ -484,18 +484,18 @@ void rtw_seccalctkipmic(u8 * key,u8 *header,u8 *data,u32 data_len,u8 *mic_code,
 
 	struct mic_data	micdata;
 	u8 priority[4]={0x0,0x0,0x0,0x0};
-_func_enter_;		
+_func_enter_;
 	rtw_secmicsetkey(&micdata, key);
 	priority[0]=pri;
-	
+
 	/* Michael MIC pseudo header: DA, SA, 3 x 0, Priority */
 	if(header[1]&1){   //ToDS==1
 			rtw_secmicappend(&micdata, &header[16], 6);  //DA
 		if(header[1]&2)  //From Ds==1
 			rtw_secmicappend(&micdata, &header[24], 6);
 		else
-			rtw_secmicappend(&micdata, &header[10], 6);		
-	}	
+			rtw_secmicappend(&micdata, &header[10], 6);
+	}
 	else{	//ToDS==0
 		rtw_secmicappend(&micdata, &header[4], 6);   //DA
 		if(header[1]&2)  //From Ds==1
@@ -506,11 +506,11 @@ _func_enter_;
 	}
 	rtw_secmicappend(&micdata, &priority[0], 4);
 
-	
+
 	rtw_secmicappend(&micdata, data, data_len);
 
 	rtw_secgetmic(&micdata,mic_code);
-_func_exit_;	
+_func_exit_;
 }
 
 
@@ -574,7 +574,7 @@ static const unsigned short Sbox1[2][256]=       /* Sbox for hash (can be in ROM
    0x038F,0x59F8,0x0980,0x1A17,0x65DA,0xD731,0x84C6,0xD0B8,
    0x82C3,0x29B0,0x5A77,0x1E11,0x7BCB,0xA8FC,0x6DD6,0x2C3A,
   },
- 
+
 
   {  /* second half of table is unsigned char-reversed version of first! */
    0xA5C6,0x84F8,0x99EE,0x8DF6,0x0DFF,0xBDD6,0xB1DE,0x5491,
@@ -611,7 +611,7 @@ static const unsigned short Sbox1[2][256]=       /* Sbox for hash (can be in ROM
    0xC382,0xB029,0x775A,0x111E,0xCB7B,0xFCA8,0xD66D,0x3A2C,
   }
 };
- 
+
  /*
 **********************************************************************
 * Routine: Phase 1 -- generate P1K, given TA, TK, IV32
@@ -653,7 +653,7 @@ _func_enter_;
         }
 _func_exit_;
 }
- 
+
 
 /*
 **********************************************************************
@@ -712,7 +712,7 @@ _func_enter_;
 	rc4key[1] =(Hi8(iv16) | 0x20) & 0x7F; /* Help avoid weak (FMS) keys  */
 	rc4key[2] = Lo8(iv16);
 	rc4key[3] = Lo8((PPK[5] ^ TK16(0)) >> 1);
-	 
+
 
 	/* Copy 96 bits of PPK[0..5] to RC4KEY[4..15]  (little-endian)       */
 	for (i=0;i<6;i++)
@@ -720,7 +720,7 @@ _func_enter_;
 		rc4key[4+2*i] = Lo8(PPK[i]);
 		rc4key[5+2*i] = Hi8(PPK[i]);
 	}
-_func_exit_;	
+_func_exit_;
 }
 
 
@@ -751,7 +751,7 @@ _func_enter_;
 
 #ifdef CONFIG_USB_TX_AGGREGATION
 	hw_hdr_offset = TXDESC_SIZE +
-		 (((struct xmit_frame*)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);	
+		 (((struct xmit_frame*)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);
 #else
 	#ifdef CONFIG_TX_EARLY_MODE
 	hw_hdr_offset = TXDESC_OFFSET+EARLY_MODE_INFO_SIZE;
@@ -773,8 +773,8 @@ _func_enter_;
 		{
 			DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
 			stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0] );
-		}	
-*/	
+		}
+*/
 		//if (stainfo!=NULL)
 		{
 /*
@@ -783,7 +783,7 @@ _func_enter_;
 				DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, stainfo->state);
 				return _FAIL;
 			}
-*/			
+*/
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_encrypt: stainfo!=NULL!!!\n"));
 
 			if(IS_MCAST(pattrib->ra))
@@ -801,7 +801,7 @@ _func_enter_;
 			for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
 				iv=pframe+pattrib->hdrlen;
 				payload=pframe+pattrib->iv_len+pattrib->hdrlen;
-				
+
 				GET_TKIP_PN(iv, dot11txpn);
 
 				pnl=(u16)(dot11txpn.val);
@@ -809,7 +809,7 @@ _func_enter_;
 
 				phase1((u16 *)&ttkey[0],prwskey,&pattrib->ta[0],pnh);
 
-				phase2(&rc4key[0],prwskey,(u16 *)&ttkey[0],pnl);	
+				phase2(&rc4key[0],prwskey,(u16 *)&ttkey[0],pnl);
 
 				if((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
 					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
@@ -827,7 +827,7 @@ _func_enter_;
 					arcfour_init(&mycontext,rc4key,16);
 					arcfour_encrypt(&mycontext, payload, payload, length);
 					arcfour_encrypt(&mycontext, payload+length, crc, 4);
-	
+
 				pframe+=pxmitpriv->frag_len;
 				pframe=(u8 *)RND4((SIZE_PTR)(pframe));
 
@@ -842,12 +842,12 @@ _func_enter_;
                         DBG_871X("%s, psta==NUL\n", __func__);
 			res=_FAIL;
 		}
-*/		
-						
+*/
+
 	}
-_func_exit_;	
+_func_exit_;
 	return res;
-				
+
 }
 
 
@@ -874,7 +874,7 @@ u32 rtw_tkip_decrypt(_adapter *padapter, u8 *precvframe)
 _func_enter_;
 
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
-	
+
 	//4 start to decrypt recvframe
 	if(prxattrib->encrypt==_TKIP_){
 
@@ -929,21 +929,21 @@ _func_enter_;
 				prwskey=&stainfo->dot118021x_UncstKey.skey[0];
 				prwskeylen=16;
 			}
-			
+
 			iv=pframe+prxattrib->hdrlen;
 			payload=pframe+prxattrib->iv_len+prxattrib->hdrlen;
 			length= ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
-				
+
 			GET_TKIP_PN(iv, dot11txpn);
 
 			pnl=(u16)(dot11txpn.val);
 			pnh=(u32)(dot11txpn.val>>16);
 
 			phase1((u16 *)&ttkey[0],prwskey,&prxattrib->ta[0],pnh);
-			phase2(&rc4key[0],prwskey,(unsigned short *)&ttkey[0],pnl);	
+			phase2(&rc4key[0],prwskey,(unsigned short *)&ttkey[0],pnl);
 
 			//4 decrypt payload include icv
-					
+
 			arcfour_init(&mycontext, rc4key,16);
 			arcfour_encrypt(&mycontext, payload, payload, length);
 
@@ -962,12 +962,12 @@ _func_enter_;
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_decrypt: stainfo==NULL!!!\n"));
 			res=_FAIL;
 		}
-						
+
 	}
-_func_exit_;	
+_func_exit_;
 exit:
 	return res;
-				
+
 }
 
 
@@ -1054,7 +1054,7 @@ static void next_key(u8 *key, sint round);
 static void byte_sub(u8 *in, u8 *out);
 static void shift_row(u8 *in, u8 *out);
 static void mix_column(u8 *in, u8 *out);
-#ifndef PLATFORM_FREEBSD 
+#ifndef PLATFORM_FREEBSD
 static void add_round_key( u8 *shiftrow_in,
                     u8 *mcol_in,
                     u8 *block_in,
@@ -1072,24 +1072,24 @@ static void aes128k128d(u8 *key, u8 *data, u8 *ciphertext);
 static void xor_128(u8 *a, u8 *b, u8 *out)
 {
     sint i;
-_func_enter_;	
+_func_enter_;
     for (i=0;i<16; i++)
     {
         out[i] = a[i] ^ b[i];
     }
-_func_exit_;		
+_func_exit_;
 }
 
 
 static void xor_32(u8 *a, u8 *b, u8 *out)
 {
     sint i;
-_func_enter_;		
+_func_enter_;
     for (i=0;i<4; i++)
     {
         out[i] = a[i] ^ b[i];
     }
-_func_exit_;		
+_func_exit_;
 }
 
 
@@ -1108,7 +1108,7 @@ static void next_key(u8 *key, sint round)
         0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
         0x1b, 0x36, 0x36, 0x36
     };
-_func_enter_;		
+_func_enter_;
     sbox_key[0] = sbox(key[13]);
     sbox_key[1] = sbox(key[14]);
     sbox_key[2] = sbox(key[15]);
@@ -1122,25 +1122,25 @@ _func_enter_;
     xor_32(&key[4], &key[0], &key[4]);
     xor_32(&key[8], &key[4], &key[8]);
     xor_32(&key[12], &key[8], &key[12]);
-_func_exit_;		
+_func_exit_;
 }
 
 
 static void byte_sub(u8 *in, u8 *out)
 {
     sint i;
-_func_enter_;			
+_func_enter_;
     for (i=0; i< 16; i++)
     {
         out[i] = sbox(in[i]);
     }
-_func_exit_;	
+_func_exit_;
 }
 
 
 static void shift_row(u8 *in, u8 *out)
 {
-_func_enter_;	
+_func_enter_;
     out[0] =  in[0];
     out[1] =  in[5];
     out[2] =  in[10];
@@ -1157,7 +1157,7 @@ _func_enter_;
     out[13] = in[1];
     out[14] = in[6];
     out[15] = in[11];
-_func_exit_;		
+_func_exit_;
 }
 
 
@@ -1172,7 +1172,7 @@ static void mix_column(u8 *in, u8 *out)
     u8 rotr[4];
     u8 temp[4];
     u8 tempb[4];
-_func_enter_;	
+_func_enter_;
     for (i=0 ; i<4; i++)
     {
         if ((in[i] & 0x80)== 0x80)
@@ -1220,7 +1220,7 @@ _func_enter_;
     xor_32(add1bf7, rotr, temp);
     xor_32(swap_halfs, rotl,tempb);
     xor_32(temp, tempb, out);
-_func_exit_;		
+_func_exit_;
 }
 
 
@@ -1231,7 +1231,7 @@ static void aes128k128d(u8 *key, u8 *data, u8 *ciphertext)
     u8 intermediatea[16];
     u8 intermediateb[16];
     u8 round_key[16];
-_func_enter_;	
+_func_enter_;
     for(i=0; i<16; i++) round_key[i] = key[i];
 
     for (round = 0; round < 11; round++)
@@ -1259,7 +1259,7 @@ _func_enter_;
             next_key(round_key, round);
         }
     }
-_func_exit_;	
+_func_exit_;
 }
 
 
@@ -1280,7 +1280,7 @@ static void construct_mic_iv(
                         )
 {
     sint i;
-_func_enter_;	
+_func_enter_;
     mic_iv[0] = 0x59;
     if (qc_exists && a4_exists) mic_iv[1] = mpdu[30] & 0x0f;    /* QoS_TC           */
     if (qc_exists && !a4_exists) mic_iv[1] = mpdu[24] & 0x0f;   /* mute bits 7-4    */
@@ -1301,7 +1301,7 @@ _func_enter_;
     #endif
     mic_iv[14] = (unsigned char) (payload_length / 256);
     mic_iv[15] = (unsigned char) (payload_length % 256);
-_func_exit_;		
+_func_exit_;
 }
 
 
@@ -1318,7 +1318,7 @@ static void construct_mic_header1(
                         uint frtype// add for CONFIG_IEEE80211W, none 11w also can use
                         )
 {
-_func_enter_;	
+_func_enter_;
     mic_header1[0] = (u8)((header_length - 2) / 256);
     mic_header1[1] = (u8)((header_length - 2) % 256);
 #ifdef CONFIG_IEEE80211W
@@ -1328,7 +1328,7 @@ _func_enter_;
 	else
 #endif //CONFIG_IEEE80211W
 		mic_header1[2] = mpdu[0] & 0xcf;    /* Mute CF poll & CF ack bits */
-    
+
     mic_header1[3] = mpdu[1] & 0xc7;    /* Mute retry, more data and pwr mgt bits */
     mic_header1[4] = mpdu[4];       /* A1 */
     mic_header1[5] = mpdu[5];
@@ -1342,7 +1342,7 @@ _func_enter_;
     mic_header1[13] = mpdu[13];
     mic_header1[14] = mpdu[14];
     mic_header1[15] = mpdu[15];
-_func_exit_;	
+_func_exit_;
 }
 
 
@@ -1359,7 +1359,7 @@ static void construct_mic_header2(
                 )
 {
     sint i;
-_func_enter_;	
+_func_enter_;
     for (i = 0; i<16; i++) mic_header2[i]=0x00;
 
     mic_header2[0] = mpdu[16];    /* A3 */
@@ -1394,7 +1394,7 @@ _func_enter_;
         mic_header2[15] = mpdu[31] & 0x00;
     }
 
-_func_exit_;	
+_func_exit_;
 }
 
 
@@ -1416,14 +1416,14 @@ static void construct_ctr_preload(
                         )
 {
     sint i = 0;
-_func_enter_;		
+_func_enter_;
     for (i=0; i<16; i++) ctr_preload[i] = 0x00;
     i = 0;
-	
+
     ctr_preload[0] = 0x01;                                  /* flag */
-    if (qc_exists && a4_exists) 
+    if (qc_exists && a4_exists)
 		ctr_preload[1] = mpdu[30] & 0x0f;   /* QoC_Control */
-    if (qc_exists && !a4_exists) 
+    if (qc_exists && !a4_exists)
 		ctr_preload[1] = mpdu[24] & 0x0f;
 #ifdef CONFIG_IEEE80211W
 	//802.11w management frame should set management bit(4)
@@ -1441,7 +1441,7 @@ _func_enter_;
     #endif
     ctr_preload[14] =  (unsigned char) (c / 256); /* Ctr */
     ctr_preload[15] =  (unsigned char) (c % 256);
-_func_exit_;		
+_func_exit_;
 }
 
 
@@ -1452,12 +1452,12 @@ _func_exit_;
 static void bitwise_xor(u8 *ina, u8 *inb, u8 *out)
 {
     sint i;
-_func_enter_;		
+_func_enter_;
     for (i=0; i<16; i++)
     {
         out[i] = ina[i] ^ inb[i];
     }
-_func_exit_;		
+_func_exit_;
 }
 
 
@@ -1482,8 +1482,8 @@ static sint aes_cipher(u8 *key, uint	hdrlen,
 //	uint	offset = 0;
 	uint	frtype  = GetFrameType(pframe);
 	uint	frsubtype  = GetFrameSubType(pframe);
-	
-_func_enter_;		
+
+_func_enter_;
 	frsubtype=frsubtype>>4;
 
 
@@ -1507,7 +1507,7 @@ _func_enter_;
 		{
 			qc_exists = 1;
 					if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
-				 
+
 					hdrlen += 2;
 			}
 		}
@@ -1519,7 +1519,7 @@ _func_enter_;
 		(frsubtype == 0x0b)))
 		{
 			if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
-				 
+
 					hdrlen += 2;
 			}
 			qc_exists = 1;
@@ -1533,7 +1533,7 @@ _func_enter_;
 	pn_vector[3]=pframe[hdrlen+5];
 	pn_vector[4]=pframe[hdrlen+6];
 	pn_vector[5]=pframe[hdrlen+7];
-	
+
 	construct_mic_iv(
                         mic_iv,
                         qc_exists,
@@ -1654,7 +1654,7 @@ _func_enter_;
     aes128k128d(key, ctr_preload, aes_out);
     bitwise_xor(aes_out, padded_buffer, chain_buffer);
     for (j=0; j<8;j++) pframe[payload_index++] = chain_buffer[j];//for (j=0; j<8;j++) message[payload_index++] = chain_buffer[j];
-_func_exit_;		
+_func_exit_;
 	return _SUCCESS;
 }
 
@@ -1666,7 +1666,7 @@ u32	rtw_aes_encrypt(_adapter *padapter, u8 *pxmitframe)
 {	// exclude ICV
 
 
-	/*static*/ 
+	/*static*/
 //	unsigned char	message[MAX_MSG_SIZE];
 
     	/* Intermediate Buffers */
@@ -1681,7 +1681,7 @@ u32	rtw_aes_encrypt(_adapter *padapter, u8 *pxmitframe)
 
 //	uint	offset = 0;
 	u32 res=_SUCCESS;
-_func_enter_;		
+_func_enter_;
 
 	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
 		return _FAIL;
@@ -1694,7 +1694,7 @@ _func_enter_;
 	hw_hdr_offset = TXDESC_OFFSET+EARLY_MODE_INFO_SIZE;
 	#else
 	hw_hdr_offset = TXDESC_OFFSET;
-	#endif	
+	#endif
 #endif
 
 	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + hw_hdr_offset;
@@ -1711,7 +1711,7 @@ _func_enter_;
 			DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
 			stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0] );
 		}
-*/		
+*/
 		//if (stainfo!=NULL)
 		{
 /*
@@ -1747,17 +1747,17 @@ _func_enter_;
 #endif //CONFIG_TDLS
 
 			prwskeylen=16;
-	
+
 			for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
-			
+
 				if((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
 					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
-				
+
 					aes_cipher(prwskey,pattrib->hdrlen,pframe, length);
 				}
 				else{
 					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;
-				
+
 					aes_cipher(prwskey,pattrib->hdrlen,pframe, length);
 				pframe+=pxmitpriv->frag_len;
 				pframe=(u8*)RND4((SIZE_PTR)(pframe));
@@ -1805,7 +1805,7 @@ static sint aes_decipher(u8 *key, uint	hdrlen,
 //	uint	offset = 0;
 	uint	frtype  = GetFrameType(pframe);
 	uint	frsubtype  = GetFrameSubType(pframe);
-_func_enter_;			
+_func_enter_;
 	frsubtype=frsubtype>>4;
 
 
@@ -1842,7 +1842,7 @@ _func_enter_;
 		{
 			qc_exists = 1;
 					if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
-				 
+
 					hdrlen += 2;
 			}
 		}//only for data packet . add for CONFIG_IEEE80211W, none 11w also can use
@@ -1853,7 +1853,7 @@ _func_enter_;
 		(frsubtype == 0x0b)))
 		{
 			if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
-				 
+
 					hdrlen += 2;
 			}
 			qc_exists = 1;
@@ -1865,7 +1865,7 @@ _func_enter_;
 	// now, decrypt pframe with hdrlen offset and plen long
 
 	payload_index = hdrlen + 8; // 8 is for extiv
-	
+
 	for (i=0; i< num_blocks; i++)
     {
         construct_ctr_preload(
@@ -1906,7 +1906,7 @@ _func_enter_;
         for (j=0; j<payload_remainder;j++) pframe[payload_index++] = chain_buffer[j];
     }
 
-	//start to calculate the mic	
+	//start to calculate the mic
 	if((hdrlen +plen+8) <= MAX_MSG_SIZE)
 		_rtw_memcpy((void *)message, pframe, (hdrlen +plen+8)); //8 is for ext iv len
 
@@ -1919,7 +1919,7 @@ _func_enter_;
 	pn_vector[5]=pframe[hdrlen+7];
 
 
-	
+
 	construct_mic_iv(
                         mic_iv,
                         qc_exists,
@@ -2052,7 +2052,7 @@ _func_enter_;
 			res = _FAIL;
 		}
 	}
-_func_exit_;	
+_func_exit_;
 	return res;
 }
 
@@ -2060,7 +2060,7 @@ u32	rtw_aes_decrypt(_adapter *padapter, u8 *precvframe)
 {	// exclude ICV
 
 
-	/*static*/ 
+	/*static*/
 //	unsigned char	message[MAX_MSG_SIZE];
 
 
@@ -2075,7 +2075,7 @@ u32	rtw_aes_decrypt(_adapter *padapter, u8 *precvframe)
 	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
 //	struct	recv_priv		*precvpriv=&padapter->recvpriv;
 	u32	res=_SUCCESS;
-_func_enter_;	 
+_func_enter_;
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
 	//4 start to encrypt each fragment
 	if((prxattrib->encrypt==_AES_)){
@@ -2138,7 +2138,7 @@ _func_enter_;
 			{
 				prwskey=&stainfo->dot118021x_UncstKey.skey[0];
 			}
-			
+
 			length= ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
 			/*// add for CONFIG_IEEE80211W, debug
 			if(0)
@@ -2171,9 +2171,9 @@ _func_enter_;
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_decrypt: stainfo==NULL!!!\n"));
 			res=_FAIL;
 		}
-						
+
 	}
-_func_exit_;	
+_func_exit_;
 exit:
 	return res;
 }
@@ -2191,7 +2191,7 @@ u32	rtw_BIP_verify(_adapter *padapter, u8 *precvframe)
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	ori_len = pattrib->pkt_len-WLAN_HDR_A3_LEN+BIP_AAD_SIZE;
 	BIP_AAD = rtw_zmalloc(ori_len);
-	
+
 	if(BIP_AAD == NULL)
 	{
 		DBG_871X("BIP AAD allocate fail\n");
@@ -2228,7 +2228,7 @@ u32	rtw_BIP_verify(_adapter *padapter, u8 *precvframe)
 		}
 		//clear the MIC field of MME to zero
 		_rtw_memset(p+2+len-8, 0, 8);
-		
+
 		//conscruct AAD, copy frame control field
 		_rtw_memcpy(BIP_AAD, &pwlanhdr->frame_ctl, 2);
 		ClearRetry(BIP_AAD);
@@ -2236,11 +2236,11 @@ u32	rtw_BIP_verify(_adapter *padapter, u8 *precvframe)
 		ClearMData(BIP_AAD);
 		//conscruct AAD, copy address 1 to address 3
 		_rtw_memcpy(BIP_AAD+2, pwlanhdr->addr1, 18);
-		
+
 		if(omac1_aes_128(padapter->securitypriv.dot11wBIPKey[padapter->securitypriv.dot11wBIPKeyid].skey
 			, BIP_AAD, ori_len, mic))
 			goto BIP_exit;
-		
+
 		/*//management packet content
 		{
 			int pp;
@@ -2268,7 +2268,7 @@ u32	rtw_BIP_verify(_adapter *padapter, u8 *precvframe)
 		}
 		else
 			DBG_871X("BIP MIC error!\n");
-		
+
 	}
 	else
 		res = RTW_RX_HANDLED;
@@ -2281,7 +2281,7 @@ BIP_exit:
 
 #ifndef PLATFORM_FREEBSD
 /* compress 512-bits */
-static int sha256_compress(struct sha256_state *md, unsigned char *buf)
+static int sha256_compress(struct rtw_sha256_state *md, unsigned char *buf)
 {
 	u32 S[8], W[64], t0, t1;
 	u32 t;
@@ -2300,7 +2300,7 @@ static int sha256_compress(struct sha256_state *md, unsigned char *buf)
 	for (i = 16; i < 64; i++) {
 		W[i] = Gamma1(W[i - 2]) + W[i - 7] + Gamma0(W[i - 15]) +
 			W[i - 16];
-	}        
+	}
 
 	/* Compress */
 #define RND(a,b,c,d,e,f,g,h,i)                          \
@@ -2311,7 +2311,7 @@ static int sha256_compress(struct sha256_state *md, unsigned char *buf)
 
 	for (i = 0; i < 64; ++i) {
 		RND(S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7], i);
-		t = S[7]; S[7] = S[6]; S[6] = S[5]; S[5] = S[4]; 
+		t = S[7]; S[7] = S[6]; S[6] = S[5]; S[5] = S[4];
 		S[4] = S[3]; S[3] = S[2]; S[2] = S[1]; S[1] = S[0]; S[0] = t;
 	}
 
@@ -2323,7 +2323,7 @@ static int sha256_compress(struct sha256_state *md, unsigned char *buf)
 }
 
 /* Initialize the hash state */
-static void sha256_init(struct sha256_state *md)
+static void sha256_init(struct rtw_sha256_state *md)
 {
 	md->curlen = 0;
 	md->length = 0;
@@ -2344,7 +2344,7 @@ static void sha256_init(struct sha256_state *md)
    @param inlen  The length of the data (octets)
    @return CRYPT_OK if successful
 */
-static int sha256_process(struct sha256_state *md, unsigned char *in,
+static int sha256_process(struct rtw_sha256_state *md, unsigned char *in,
 			  unsigned long inlen)
 {
 	unsigned long n;
@@ -2385,7 +2385,7 @@ static int sha256_process(struct sha256_state *md, unsigned char *in,
    @param out [out] The destination of the hash (32 bytes)
    @return CRYPT_OK if successful
 */
-static int sha256_done(struct sha256_state *md, unsigned char *out)
+static int sha256_done(struct rtw_sha256_state *md, unsigned char *out)
 {
 	int i;
 
@@ -2437,7 +2437,7 @@ static int sha256_done(struct sha256_state *md, unsigned char *out)
 static int sha256_vector(size_t num_elem, u8 *addr[], size_t *len,
 		  u8 *mac)
 {
-	struct sha256_state ctx;
+	struct rtw_sha256_state ctx;
 	size_t i;
 
 	sha256_init(&ctx);
@@ -3038,7 +3038,7 @@ void wpa_tdls_generate_tpk(_adapter *padapter, PVOID sta)
 	}
 	_rtw_memcpy(data + 2 * ETH_ALEN, get_bssid(pmlmepriv), ETH_ALEN);
 
-	sha256_prf(key_input, SHA256_MAC_LEN, "TDLS PMK", data, sizeof(data), (u8 *) &psta->tpk, sizeof(psta->tpk));	
+	sha256_prf(key_input, SHA256_MAC_LEN, "TDLS PMK", data, sizeof(data), (u8 *) &psta->tpk, sizeof(psta->tpk));
 
 
 }
@@ -3054,7 +3054,7 @@ void wpa_tdls_generate_tpk(_adapter *padapter, PVOID sta)
  *
  * Calculate MIC for TDLS frame.
  */
-int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq, 
+int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq,
 							u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie,
 							u8 *mic)
 {
@@ -3094,7 +3094,7 @@ int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq,
 	_ftie = (struct wpa_tdls_ftie *) pos;
 	_rtw_memset(_ftie->mic, 0, TDLS_MIC_LEN);
 	pos += 2 + ftie[1];
- 
+
 	ret = omac1_aes_128(kck, buf, pos - buf, mic);
 	rtw_mfree(buf, len);
 	return ret;
@@ -3113,14 +3113,14 @@ int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq,
  *
  * Calculate MIC for TDLS TEARDOWN frame according to Section 10.22.5 in IEEE 802.11 - 2012.
  */
-int wpa_tdls_teardown_ftie_mic(u8 *kck, u8 *lnkid, u16 reason, 
+int wpa_tdls_teardown_ftie_mic(u8 *kck, u8 *lnkid, u16 reason,
 	u8 dialog_token, u8 trans_seq, u8 *ftie, u8 *mic)
 {
 	u8 *buf, *pos;
 	struct wpa_tdls_ftie *_ftie;
 	int ret;
 	int len = 2 + lnkid[1] + 2 + 1 + 1 + 2 + ftie[1];
-	
+
 	buf = rtw_zmalloc(len);
 	if (!buf) {
 		DBG_871X("TDLS: No memory for MIC calculation\n");
@@ -3163,7 +3163,7 @@ int tdls_verify_mic(u8 *kck, u8 trans_seq,
 	    timeoutie == NULL || ftie == NULL){
 		return _FAIL;
 	}
-	
+
 	len = 2 * ETH_ALEN + 1 + 2 + 18 + 2 + *(rsnie+1) + 2 + *(timeoutie+1) + 2 + *(ftie+1);
 
 	buf = rtw_zmalloc(len);
@@ -3217,10 +3217,10 @@ void rtw_use_tkipkey_handler(RTW_TIMER_HDL_ARGS)
 {
         _adapter *padapter = (_adapter *)FunctionContext;
 
-_func_enter_;			
+_func_enter_;
 
 	RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler ^^^\n"));
-	
+
 /*
 	if (RTW_CANNOT_RUN(padapter)) {
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler (padapter->bDriverStopped %s)(padapter->bSurpriseRemoved %s)^^^\n"
@@ -3230,12 +3230,12 @@ _func_enter_;
 		return;
 	}
 	*/
-	
+
 	padapter->securitypriv.busetkipkey=_TRUE;
 
 	RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler padapter->securitypriv.busetkipkey=%d^^^\n",padapter->securitypriv.busetkipkey));
 
-_func_exit_;	
+_func_exit_;
 
 }
 
@@ -3305,7 +3305,7 @@ u16 rtw_cal_crc16(u8 data, u16 crc)
 		crc_bit11 = ((crc & BIT11) ? 1 : 0) ^ shift_in;
 
 		if (crc_bit11 == 0)
-			crc_result &= (~BIT12); 
+			crc_result &= (~BIT12);
 		else
 			crc_result |= BIT12;
 
@@ -3335,7 +3335,7 @@ u16 rtw_calc_crc(u8  *pdata, int length)
 {
 	u16 crc = 0xffff;
 	int i;
-	
+
 	for (i = 0; i < length; i++)
 		crc = rtw_cal_crc16(pdata[i], crc);
 	/* get 1' complement */
diff --git a/include/rtw_security.h b/include/rtw_security.h
index 3babf5c..c93fb44 100644
--- a/include/rtw_security.h
+++ b/include/rtw_security.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -71,9 +71,9 @@ typedef enum {
 #endif
 
 union pn48	{
-	
+
 	u64	val;
-	
+
 #ifdef CONFIG_LITTLE_ENDIAN
 
 struct {
@@ -86,7 +86,7 @@ struct {
   u8 TSC6;
   u8 TSC7;
 } _byte_;
- 
+
 #elif defined(CONFIG_BIG_ENDIAN)
 
 struct {
@@ -99,7 +99,7 @@ struct {
   u8 TSC1;
   u8 TSC0;
 } _byte_;
- 
+
 #endif
 
 };
@@ -123,18 +123,18 @@ typedef struct _RT_PMKID_LIST
 
 struct security_priv
 {
-	u32	  dot11AuthAlgrthm;		// 802.11 auth, could be open, shared, 8021x and authswitch 
+	u32	  dot11AuthAlgrthm;		// 802.11 auth, could be open, shared, 8021x and authswitch
 	u32	  dot11PrivacyAlgrthm;	// This specify the privacy for shared auth. algorithm.
 
 	/* WEP */
 	u32	  dot11PrivacyKeyIndex;	// this is only valid for legendary wep, 0~3 for key id. (tx key index)
-	union Keytype dot11DefKey[4];			// this is only valid for def. key	
+	union Keytype dot11DefKey[4];			// this is only valid for def. key
 	u32 	dot11DefKeylen[4];
 	u8 	key_mask; /* use to restore wep key after hal_init */
 
-	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key 
+	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key
 	u32	dot118021XGrpKeyid;		// key id used for Grp Key ( tx key index)
-	union Keytype	dot118021XGrpKey[4];	// 802.1x Group Key, for inx0 and inx1	
+	union Keytype	dot118021XGrpKey[4];	// 802.1x Group Key, for inx0 and inx1
 	union Keytype	dot118021XGrptxmickey[4];
 	union Keytype	dot118021XGrprxmickey[4];
 	union pn48		dot11Grptxpn;			// PN48 used for Grp Key xmit.
@@ -146,19 +146,19 @@ struct security_priv
 	union pn48		dot11wBIPrxpn;			// PN48 used for Grp Key recv.
 #endif //CONFIG_IEEE80211W
 #ifdef CONFIG_AP_MODE
-	//extend security capabilities for AP_MODE 
+	//extend security capabilities for AP_MODE
 	unsigned int dot8021xalg;//0:disable, 1:psk, 2:802.1x
 	unsigned int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
 	unsigned int wpa_group_cipher;
 	unsigned int wpa2_group_cipher;
 	unsigned int wpa_pairwise_cipher;
-	unsigned int wpa2_pairwise_cipher;	
+	unsigned int wpa2_pairwise_cipher;
 #endif
 
 	u8 wps_ie[MAX_WPS_IE_LEN];//added in assoc req
 	int wps_ie_len;
-	
-	
+
+
 	u8	binstallGrpkey;
 #ifdef CONFIG_GTK_OL
 	u8	binstallKCK_KEK;
@@ -170,12 +170,12 @@ struct security_priv
 	//_timer tkip_timer;
 	u8	bcheck_grpkey;
 	u8	bgrpkey_handshake;
-	
+
 	//u8	packet_cnt;//unused, removed
-	
+
 	s32	sw_encrypt;//from registry_priv
 	s32	sw_decrypt;//from registry_priv
-	
+
 	s32 	hw_decrypted;//if the rx packets is hw_decrypted==_FALSE, it means the hw has not been ready.
 
 
@@ -196,7 +196,7 @@ struct security_priv
 
 
 	//for tkip countermeasure
-	u32 last_mic_err_time;	
+	u32 last_mic_err_time;
 	u8	btkip_countermeasure;
 	u8	btkip_wait_report;
 	u32 btkip_countermeasure_time;
@@ -238,7 +238,7 @@ struct security_priv
 #endif /* DBG_SW_SEC_CNT */
 };
 
-struct sha256_state {
+struct rtw_sha256_state {
 	u64 length;
 	u32 state[8], curlen;
 	u8 buf[64];
@@ -401,7 +401,7 @@ static inline u32 rotr(u32 val, int bits)
 		(a)[6] = (u8) (((u64) (val)) >> 8);	\
 		(a)[7] = (u8) (((u64) (val)) & 0xff);	\
 	} while (0)
-	
+
 /* ===== start - public domain SHA256 implementation ===== */
 
 /* This is based on SHA256 implementation in LibTomCrypt that was released into
@@ -430,7 +430,7 @@ static const unsigned long K[64] = {
 ( ((((unsigned long) (x) & 0xFFFFFFFFUL) >> (unsigned long) ((y) & 31)) | \
    ((unsigned long) (x) << (unsigned long) (32 - ((y) & 31)))) & 0xFFFFFFFFUL)
 #define Ch(x,y,z)       (z ^ (x & (y ^ z)))
-#define Maj(x,y,z)      (((x | y) & z) | (x & y)) 
+#define Maj(x,y,z)      (((x | y) & z) | (x & y))
 #define S(x, n)         RORc((x), (n))
 #define R(x, n)         (((x)&0xFFFFFFFFUL)>>(n))
 #define Sigma0(x)       (S(x, 2) ^ S(x, 13) ^ S(x, 22))
@@ -468,12 +468,12 @@ u32	rtw_BIP_verify(_adapter *padapter, u8 *precvframe);
 #endif //CONFIG_IEEE80211W
 #ifdef CONFIG_TDLS
 void wpa_tdls_generate_tpk(_adapter *padapter, PVOID sta);
-int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq, 
+int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq,
 						u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie,
 						u8 *mic);
-int wpa_tdls_teardown_ftie_mic(u8 *kck, u8 *lnkid, u16 reason, 
+int wpa_tdls_teardown_ftie_mic(u8 *kck, u8 *lnkid, u16 reason,
 	u8 dialog_token, u8 trans_seq, u8 *ftie, u8 *mic);
-int tdls_verify_mic(u8 *kck, u8 trans_seq, 
+int tdls_verify_mic(u8 *kck, u8 trans_seq,
 						u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie);
 #endif //CONFIG_TDLS
 
-- 
2.26.2

